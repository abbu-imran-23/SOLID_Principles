/*** SOLID Principles
 ** 1. Single Responsibility Principle
 **    - A class should have only one reason to change, meaning it should have only one responsibility or
 **      function.
 **    - Why Use: Reduces code complexity and avoids tightly coupled code, making debugging and updates easier.
 **    - Advantages: Improves code readability and maintainability, reduces bugs during changes.
 **    - Disadvantages: Can increase the number of classes, adding to initial development time.
 **
 ** 2. Open Closed Principle
 **    - Software entities should be open for extension but closed for modification.
 **    - Why Use: Ensures flexibility and adaptability to future requirements without altering existing code.
 **    - Advantages: Facilitates scalability and protects existing functionality.
 **    - Disadvantages: Requires careful planning and abstraction, which can be time-consuming.
 **
 ** 3. Liskov Substitution Principle
 **    - Objects of a superclass should be replaceable with objects of its subclasses without altering the
 **      programâ€™s correctness.
 **    - Why Use: Ensures derived classes are substitutable, maintaining program stability.
 **    - Advantages: Enhances code reusability and reduces errors from unexpected behavior.
 **    - Disadvantages: Over-engineering to strictly adhere to this principle can complicate code.
 **
 ** 4. Interface Segregation Principle
 **    - A class should not be forced to implement interfaces it does not use; create smaller, specific
 **      interfaces instead.
 **    - Why Use: Prevents creating "fat" interfaces with irrelevant methods for some classes.
 **    - Advantages: Simplifies implementation and reduces coupling between classes and interfaces.
 **    - Disadvantages: Can lead to a larger number of interfaces, increasing management overhead.
 **
 ** 5. Dependency Inversion Principle
 **    - High-level modules should not depend on low-level modules; both should depend on abstractions.
 **    - Why Use: Decouples modules, making the system more flexible and reusable.
 **    - Advantages: Improves module independence and testability, easier modification and extension.
 **    - Disadvantages: Adds complexity due to managing abstractions.
 **/

/*** Overview of SOLID Principles
 ** - SOLID principles improve modularity, readability, and maintainability of code.
 ** - They support scalable, testable, and less error-prone systems.
 **/

/*** Advantages of SOLID Principles
 ** 1. Improved Maintainability: Enables safer changes to the system with minimal risk.
 ** 2. Enhanced Testability: Independent components simplify unit testing.
 ** 3. Better Scalability: Facilitates adaptation to changing requirements.
 ** 4. Reduced Code Complexity: Makes debugging and enhancements straightforward.
 ** 5. Facilitates Collaboration: Modular design allows separate team development.
 **/

/*** Disadvantages of SOLID Principles
 ** 1. Initial Overhead: Requires careful planning and abstraction.
 ** 2. Over-Engineering: Strict adherence can lead to unnecessary complexity.
 ** 3. Learning Curve: Developers need time to understand and apply these principles.
 ** 4. Increased Class/Interface Count: Leads to navigation challenges for newcomers.
 **/

/*** Conclusion
 ** - SOLID principles are key to effective object-oriented design.
 ** - Proper application ensures robust, maintainable, and adaptable systems.
 ** - Balance their use with practical needs to avoid over-engineering.
 **/
